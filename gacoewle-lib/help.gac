" This document describes a paradigm called
  FGFH (Fycoide-Based Gacœùle Formalism by 
  HYY), a Gacœùle grammatical description 
  framework created by HYY. Its core is the
  use of composable abstract units called
  Fycoides to formally define the lexicon,
  phonology, and evolutionary rules of the
  Gacœùle language."

---- File Type ----

" Regular files are *.gac, header files are *.fyc "

#[stddef.fyc];                 "Import fyc library"
" Standard definition header file, defines commonly used Fycoides like desc, V, C, null, etc."

---- File Attributes ----

#(file_metadata) <- {          "Define document attributes"
  #(file) <- {
    #(file_name) <- 'help',    "Document name"
    #(file_type) <- 'gac'      "File extension"
  },
  #(author) <- 'Heyangyang',   "Author"
  #(description) <- 'help'     "Description"
};

---- Data Types ----

" Only data of the same type can co-evolve "

#(MORP00) :: [_];              "Word type"
#(DESC00) :: '_';              "Description type"

---- Definition and Assignment ----

#(DEFN00) :: [_];              "Define single-attribute Fycoide"
" Structures like #(xxx) are called Fycoides or Gacœùle Grammar Description Templates "

#(DEFN01) :: {                 "Define multi-attribute Fycoide"
  " Within a single Fycoide, there can be one and only one instance of the same data type, except when nesting Fycoides."
  '_',
  '_', -- ERROR: Syntax Error: Duplicate data type definition
  [_],
};

#(DESC00) <- 'desc';           "Fycoide assignment"

#(DEFN02) :: {                 "Nested multi-attribute Fycoide"
  #(DESC00) <- 'desc',
  " Here, the description type value within #(DESC00) is temporarily assigned and is only effective within the current definition scope. "
  #(MORP00) <- [morp]
};

#(flu_i) :: {
  " Define a flu_i "
  [_] <- *[ i | #(null) ]          " Direct Fycoide call"
  " When calling a Fycoide, the corresponding data structure is automatically selected. "
};

#(flu_i_exists) :: {               "Conditional definition"
  " This code demonstrates the sequential execution of conditional judgments. "
  #(desc) <- 'if_flu_i_exists',
  '_' <- {
    *[#(flu_i)@0] >> {
    " Check if flu_i is null "
    " The @0 here indicates capturing the smallest preceding combination as a capture group, indexed by position and stored in an internal temporary mapping. "
      *[#(null)]@0 >> 'true',
      " If the word value of flu_i is null, then define flu_i_exists as true. "
      " The @0 here, used as a reference suffix, checks if the content at this address matches what is actually stored in the internal mapping. "
      [#(_)]@0 >> 'false'
      " If the word value of flu_i matches the word value of flu_i (i.e., in all cases), then define flu_i_exists as false. "
    }
  }
};

#(append_a) :: {                   "Recursive definition"
  [_] <- {
    [ a | #(append_a) ]
    " Here, a Fycoide named append_a is defined recursively, specifically manifesting as the concatenation of one or more word types 'a'. "
  }
};

#(MORP04) :: {                     "Capture assignment"
  " Here, using a capture group, only a part of the word type is selected for assignment. "
  [_]@0 <- [[hello]@0world]
};

#(MORP04_is_hello) :: {
  " The description value of MORP04_is_hello here is false. "
  '_' <- {
    [#(MORP04)]@0 >> {
      [hello]@0 >> 'true',
      [_]@0 >> 'false'
    }
  }
};

#(MORP01) :: { [_] <- [a] };       "Example: Word concatenation"
#(MORP02) :: { [_] <- [b] };
#(MORP03) :: {
  " Define MORP03 as the concatenated combination of MORP01 and MORP02."
  [_] <- [#(MORP01)#(MORP02)]
};

---- Evolution ----

*[                                 "Unconditional evolution"
  acli-ori+a|>os
  =bel-sim+o+a
] -> [acueres];
" Here, *[xx] represents the reconstructed form of the proto-language, and the data type is still the word type. "

---- Common Special Symbols within Words ----
  =                 Gacœùle root boundary
  -                 Gacœùle stem-affix separator
  +a,   +o          Proto-Gacœùle masculine/feminine
  |>os, |>ar        Proto-Gacœùle morphological suffixes
  |>xx-xx           Proto-Gacœùle agglutinative endings
  <|                Gacœùle prefix marker
  |                 Or
  &                 And
  x!, [xxx]!        Not
  .                 Grouping (for readability, no syntactic meaning, each group must have at least one actual phoneme or Fycoide)
  [.x], [x.]        Indicates possible other phonemes before/after this word type
  ...               Ellipsis for possible phonemes
  [xx]?             Uncertain part
----

[c] -> {                           "Condition"
  [ #(_) [e|i]   ] >> [qu],
  " The expression before the >> conditional branch operator describes the evolution condition for the target word. #(_) is a placeholder Fycoide, used to indicate the situation where the target word as a whole is in this position. This branch evolution means: when c is immediately followed by e or i, it becomes qu. "
  [ #(_) [a|o|u] ] >> [c]
  " When c is immediately followed by a or o or u, it remains c. "
};

*[c, z] -> {                       "Multiple evolution"
  " Separated by commas. "
  [ #(_) [e|i]   ] >> [qu, c],
  [ #(_) [a|o|u] ] >> [c, ch]
};

*[-o...] -> {                      "Nested conditional evolution"
  *[#(root)#(flu_i)@0=#(_)] >> {
    " The @0 here marks the preceding part for participation in the following condition matching. The format can be a Fycoide or a word. "
    *[i]@0 >> [e],
    " When the #(flu_i) at the parent condition @0 is *[i], evolve to [e]. "
    *[#(null)]@0 >> [o]
    " When the #(flu_i) at the parent condition @0 is [#(null)], evolve to [o]. "
  }
};

[] -> {                            "Example"
  " Gacœùle vowel supplementation rule, essentially a long-distance vowel harmony phenomenon. "
  [
    [
      *[=#(Cs)]
      #(_)
      *[#(Cs)#(V)@1#(Cs)=]
    ]
    |
    [
      *[=#(Cs)#(V)@1#(Cs)]
      #(_)
      *[#(Cs)=]
    ]
  ] >> {
    *[a]@1 >> [ i ],
    *[e]@1 >> [ a ],
    *[i]@1 >> [ e ],
    *[o]@1 >> [ o ],
    *[u]@1 >> [ u ]
  }
};


---- Capture Evolution ----

*[hello] @> { [#(V)] >> [#(null)] };
" Traverse and replace all minimal capture groups satisfying the condition, equivalent to evolving to [hll]. "

*[hello] @> { [#(_)]@2 >> [x] };
" Traverse to the third minimal capture group, evolve it to x, equivalent to evolving to [hexlo]. "

*[hello] @> { [#(V)]@[0&1] >> [x] };
" Traverse to the first and second minimal capture groups, if they are V, evolve to x, equivalent to evolving to [hxllo]. "
" The usage of @[0&2] is because all adjacent numeric characters following @ are read together as the match group address."

*[[he]llo] @> {
  " In this example, [he] is treated as one minimal capture group, equivalent to evolving to [hexlxlxox]. "
  *[#(_)] >> [#(_)x]
};

#(StackTest) :: {
  " Define a Fycoide representing a stack. "
  [_] <- [#(null) | #(_)#(StackTest)]
};

*[hello] @> #(StackTest);
" Evolve via Stack to the reverse [olleh]. "
" h process: h + #(StackTest) -> h + #(null) = h
  e process: e + #(StackTest) -> e + h = eh
  l process: l + #(StackTest) -> l + eh = leh
  l process: l + #(StackTest) -> l + leh = lleh
  o process: o + #(StackTest) -> o + lleh = olleh
  This example proves that the definition is not a recursive call to itself, but a reference to the already constructed result data. During the traversal of @>, each position can obtain the result accumulated from the previous steps, indicating that FGFH is descriptive rather than procedural. "

---- Formula Definition ----

#(AppendE) :: {
  [_] <- [#(_)e]
  " The usage of the placeholder in the assignment statement is similar to that in conditional statements; here it is used as an input slot. "
};

[blond] -> [#(AppendE)]; "[blond] -> [blonde]"
[grand] -> [#(AppendE)]; "[grand] -> [grande]"

---- Lexeme Definition ----

#[lexique.fyc];             "Import lexique.fyc header file"

*[acli+a|>os] :: {          "Define lexeme"
  #(iveygnenes) <- 'acues', "Define modern spelling"
  #(part_of_speech) <- {    "Define part of speech"
    #(static) <- 'masculine'
  },
  #(gloss)  <- 'water'      "Define meaning"
};

---- Fycoide Operator Syntax

Fycoide supports two equivalent operator syntaxes.
Choose freely based on your preference, or mix both
styles.

== Operator Reference

╭────────┬───────────┬─────────────────────╮
│ Symbol │  Keyword  │       Meaning       │
├────────┼───────────┼─────────────────────┤
│   ::   │ shapes    │ Define structure    │
│   <-   │ holds     │ Assign value        │
│   ->   │ shifts    │ Sound evolution     │
│   >>   │ triggers  │ Conditional branch  │
│   @>   │ flows     │ Apply pattern       │
╰────────┴───────────┴─────────────────────╯

== Examples

Symbolic Style:

╭─FGFH──────────────────────────────╮
│ #(Stack) :: {                     │
│   [_] <- [#(null) | #(_)#(Stack)] │
│ };                                │
│ *[hello] @> #(Stack);             │
│ [c] -> {                          │
│   [ #(_) [e|i] ] >> [qu]          │
│ };                                │
╰───────────────────────────────────╯

╭─FGFH──────────────────────────────╮
│ #(Stack) shapes {                 │
│   [_] holds [                     │
│     #(null) | #(_)#(Stack)        │
│   ]                               │
│ };                                │
│ *[hello] flows #(Stack);          │
│ [c] shifts {                      │
│   [ #(_) [e|i] ] triggers [qu]    │
│ };                                │
╰───────────────────────────────────╯

Both syntaxes are fully supported by the syntax 
checker and can be used interchangeably.

----
